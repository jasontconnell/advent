package main

import (
	"container/heap"
	"fmt"
	"math"
	"os"
	"sort"
	"strings"
	"time"
)

var inputFilename = "input.txt"

type output = int

var origFloors []map[string]bool

type pqueue []*state

func (pq pqueue) Len() int { return len(pq) }

func (pq pqueue) Less(i, j int) bool {
	return pq[i].score < pq[j].score
}

func (pq *pqueue) Pop() interface{} {
	old := *pq
	n := len(old)
	st := old[n-1]
	*pq = old[0 : n-1]
	return st
}

func (pq *pqueue) Push(x interface{}) {
	st := x.(*state)
	*pq = append(*pq, st)
}

func (pq pqueue) Swap(i, j int) {
	pq[i], pq[j] = pq[j], pq[i]
}

type state struct {
	moves        int
	floors       []map[string]bool
	elevator     map[string]bool
	currentLevel int
	score        float64
	steps        []move
	movemap      map[string]bool
	mv           move
}

type move struct {
	pickup  map[string]bool
	deliver map[string]bool
	level   int
}

func (m move) String() string {
	return fmt.Sprintf("pickup: %v deliver: %v to level %d", sortedKeys(m.pickup), sortedKeys(m.deliver), m.level)
}

func (m move) key(level int) string {
	return fmt.Sprintf("p:%v d:%v l:%d c:%d", sortedKeys(m.pickup), sortedKeys(m.deliver), m.level, level)
}

func copymap(m map[string]bool) map[string]bool {
	cp := make(map[string]bool)
	for k, v := range m {
		cp[k] = v
	}
	return cp
}

func maplist(list []string) map[string]bool {
	m := map[string]bool{}
	for _, s := range list {
		m[s] = true
	}
	return m
}

func copyFloors(floors []map[string]bool) []map[string]bool {
	cp := make([]map[string]bool, len(floors))
	for i := 0; i < len(floors); i++ {
		cp[i] = copymap(floors[i])
	}
	return cp
}

func getKey(floors []map[string]bool, elevator map[string]bool, level int, mv move) string {
	key := "" //fmt.Sprintf("dir %d|", mv.level-level)
	for _, r := range floors {
		key += "|" + floorKey(r)
	}
	key += mv.key(level)
	return key
}

func floorKey(m map[string]bool) string {
	list := sortedKeys(m)
	return listkey(list)
}

func sortedKeys(m map[string]bool) []string {
	list := []string{}
	for k := range m {
		list = append(list, k)
	}
	sort.Strings(list)
	return list
}

func listkey(list []string) string {
	return strings.Join(list, ",")
}

func isComplete(floors []map[string]bool, elevator map[string]bool, level int) bool {
	if level != len(floors)-1 {
		return false
	}
	if len(elevator) > 0 {
		return false
	}
	complete := true
	for i, m := range floors {
		if i != len(floors)-1 && len(m) > 0 {
			complete = false
			break
		}
	}
	return complete
}

func getScore(moves int, floors []map[string]bool, level int) float64 {
	dist := len(floors[0])*1000 + len(floors[1])*100 + len(floors[2])*10 + len(floors[3])
	return float64(dist)
}

func main() {
	startTime := time.Now()

	origFloors = make([]map[string]bool, 4)
	origFloors[0] = map[string]bool{"PO-G": true, "TH-G": true, "TH-M": true, "PR-G": true, "RU-G": true, "RU-M": true, "CO-G": true, "CO-M": true}
	origFloors[1] = map[string]bool{"PO-M": true, "PR-M": true}
	origFloors[2] = map[string]bool{}
	origFloors[3] = map[string]bool{}

	runExample := len(os.Args) > 1 && os.Args[1] == "example"
	if runExample {
		fmt.Println("using example input")
		example := []map[string]bool{{"HH-M": true, "LL-M": true}, {"HH-G": true}, {"LL-G": true}}
		origFloors[0] = example[0]
		origFloors[1] = example[1]
		origFloors[2] = example[2]
	}

	p1 := part1(origFloors)
	fmt.Println("done part 1", time.Since(startTime), p1)
	p2 := part2(origFloors)

	fmt.Println("--2016 day 11 solution--")
	fmt.Println("(this one takes a few minutes)")
	fmt.Println("Part 1:", p1)
	fmt.Println("Part 2:", p2)

	fmt.Println("Time", time.Since(startTime))
}

func part1(floors []map[string]bool) output {
	b, i := simulate(floors)
	if b {
		return i
	}
	return 0
}

func part2(floors []map[string]bool) output {
	return 0
	for _, s := range []string{"EL-G", "EL-M", "DI-G", "DI-M"} {
		floors[0][s] = true
	}
	b, i := simulate(floors)
	if b {
		return i
	}
	return 0
}

func simulate(floors []map[string]bool) (bool, int) {
	floorInit := copyFloors(floors)
	queue := pqueue{}

	initial := newState(floorInit, map[string]bool{}, 0)
	heap.Init(&queue)
	queue.Push(initial)

	visited := make(map[string]int)
	moves := math.MaxInt32
	solved := false
	start := time.Now()
	itr := 0

	for queue.Len() > 0 {
		cur := (heap.Pop(&queue)).(*state)

		key := getKey(cur.floors, cur.elevator, cur.currentLevel, cur.mv)
		if m, ok := visited[key]; ok && cur.moves > m {
			continue
		}
		visited[key] = cur.moves

		if isComplete(cur.floors, cur.elevator, cur.currentLevel) && cur.moves < moves {
			fmt.Println("solved", cur.floors, cur.moves)
			for _, step := range cur.steps {
				fmt.Println(step)
			}
			moves = cur.moves
			solved = true
			continue
		}

		if cur.moves > moves {
			continue
		}

		mvs := getValidMoves(cur.floors, cur.elevator, cur.currentLevel)
		for _, mv := range mvs {
			// fmt.Println(mv)
			transit := transitState(cur, mv)
			// valid := isUniqueMove(transit, mv)
			// key := getKey(transit.floors, transit.elevator, transit.currentLevel, mv)
			// if m, ok := visited[key]; (ok && transit.moves > m) || !valid {
			// 	continue
			// }
			// visited[key] = transit.moves
			queue = append(queue, transit)
		}

		if itr%10000 == 0 && queue.Len() > 0 {
			fmt.Println(itr, time.Since(start), "visited", len(visited), "queue", queue.Len(), "moves", cur.moves, "score:", cur.score)
			start = time.Now()
		}
		itr++
	}

	fmt.Println("queue len", len(queue))
	return solved, moves
}

func copyState(st *state) *state {
	cp := new(state)
	cp.floors = copyFloors(st.floors)
	cp.elevator = copymap(st.elevator)
	cp.currentLevel = st.currentLevel
	cp.moves = st.moves
	// cp.steps = make([]move, len(st.steps))
	copy(cp.steps, st.steps)
	// cp.movemap = copymap(st.movemap)
	return cp
}

func isUniqueMove(st *state, mv move) bool {
	// key := mv.key(st.currentLevel)
	// _, ok := st.movemap[key]
	// st.movemap[key] = true

	// return !ok
	return true
}

func transitState(st *state, mv move) *state {
	cp := copyState(st)

	cp.floors[cp.currentLevel], cp.elevator = transfer(cp.floors[cp.currentLevel], cp.elevator, mv.pickup)
	cp.elevator, cp.floors[mv.level] = transfer(cp.elevator, cp.floors[mv.level], mv.deliver)

	cp.moves++
	cp.mv = mv
	cp.currentLevel = mv.level
	// cp.movemap[mv.key(st.currentLevel)] = true
	cp.score = getScore(cp.moves, cp.floors, cp.currentLevel)
	// cp.steps = append(cp.steps, mv)
	return cp
}

func newState(floors []map[string]bool, elevator map[string]bool, level int) *state {
	cp := new(state)
	cp.moves = 0
	cp.floors = copyFloors(floors)
	cp.elevator = copymap(elevator)
	cp.currentLevel = level
	cp.steps = []move{}
	cp.movemap = map[string]bool{}
	return cp
}

func transfer(from map[string]bool, to map[string]bool, elements map[string]bool) (map[string]bool, map[string]bool) {
	for element := range elements {
		if _, ok := from[element]; ok {
			if _, ok := to[element]; !ok {
				delete(from, element)
				to[element] = true
			}
		}
	}
	return from, to
}

func getValidMoves(floors []map[string]bool, elevator map[string]bool, currentLevel int) []move {
	mvs := getAllMoves(floors, elevator, currentLevel)
	validMoves := []move{}

	for _, mv := range mvs {
		valid := true

		if !safeToRemove(floors[currentLevel], mv.pickup) || !safeToAdd(floors[mv.level], mv.deliver) {
			valid = false
		}

		if valid {
			validMoves = append(validMoves, mv)
		}
	}
	return validMoves
}

func getAllMoves(floors []map[string]bool, elevator map[string]bool, currentLevel int) []move {
	elevatorKeys := sortedKeys(elevator)
	floorKeys := sortedKeys(floors[currentLevel])

	mvs := []move{}
	for _, level := range []int{currentLevel + 1, currentLevel - 1} {
		if level < 0 || level == len(floors) {
			continue
		}
		if level < currentLevel && len(elevatorKeys) == 2 {
			continue
		}

		toElevator := [][]string{}

		if len(floorKeys) > 0 {
			m := map[string]bool{}
			for j := 0; j < len(floorKeys); j++ {
				left := floorKeys[j]
				for r := j + 1; r < len(floorKeys); r++ {
					right := floorKeys[r]

					if len(elevatorKeys) == 0 && level > currentLevel {
						toElevator = append(toElevator, []string{left, right})
					}
					if _, ok := m[right]; !ok && len(elevatorKeys) < 2 {
						toElevator = append(toElevator, []string{right})
					}
					m[right] = true
				}
				if _, ok := m[left]; !ok && len(elevatorKeys) < 2 {
					toElevator = append(toElevator, []string{left})
				}
				m[left] = true
			}
		}

		for i := 0; i < len(toElevator); i++ {
			em := toElevator[i]

			if len(em) > 0 {
				left := em[0]
				if len(em) == 2 {
					right := em[1]

					mvs = append(mvs,
						move{
							level:   level,
							pickup:  map[string]bool{left: true, right: true},
							deliver: map[string]bool{left: true, right: true},
						})

					mvs = append(mvs,
						move{
							level:   level,
							pickup:  map[string]bool{left: true, right: true},
							deliver: map[string]bool{left: true},
						})
					mvs = append(mvs,
						move{
							level:   level,
							pickup:  map[string]bool{left: true, right: true},
							deliver: map[string]bool{right: true},
						})
					mvs = append(mvs,
						move{
							level:   level,
							pickup:  map[string]bool{right: true},
							deliver: map[string]bool{right: true},
						})
				}

				mvs = append(mvs,
					move{
						level:   level,
						pickup:  map[string]bool{left: true},
						deliver: map[string]bool{left: true},
					})
			}

			// mvs = append(mvs, move{level: level})
		}
	}

	return mvs
}

func safeToRemove(row map[string]bool, elements map[string]bool) bool {
	if len(elements) == 0 {
		return true
	}
	cp := make(map[string]bool, len(row))
	for element := range row {
		cp[element] = true
	}
	for element := range elements {
		delete(cp, element)
	}
	return rowValid(cp)
}

func safeToAdd(row map[string]bool, elements map[string]bool) bool {
	if len(elements) == 0 {
		return true
	}
	cp := make(map[string]bool, len(row))
	for element, _ := range row {
		cp[element] = true
	}
	for element := range elements {
		cp[element] = true
	}
	return rowValid(cp)
}

func rowValid(row map[string]bool) bool {
	result := true
	for element, _ := range row {
		if isMicrochip(element) && !containsOwnGenerator(row, element) && containsOtherGenerator(row, element) {
			result = false
		}
	}

	return result
}

func isMicrochip(element string) bool {
	return strings.HasSuffix(element, "-M")
}

func containsOwnGenerator(row map[string]bool, element string) bool {
	gen := string(element[0:2]) + "-G"
	_, ok := row[gen]
	return ok
}

func containsOtherGenerator(row map[string]bool, element string) bool {
	result := false
	el := string(element[0:2])

	for r, _ := range row {
		if strings.HasSuffix(r, "-G") && !strings.HasPrefix(r, el) {
			result = true
		}
	}
	return result
}
