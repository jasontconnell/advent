package main

import (
	"container/heap"
	"fmt"
	"math"
	"os"
	"sort"
	"strings"
	"time"
)

var inputFilename = "input.txt"

type output = int

type pqueue []*state

func (pq pqueue) Len() int { return len(pq) }

func (pq pqueue) Less(i, j int) bool {
	return pq[i].score < pq[j].score
}

func (pq *pqueue) Pop() interface{} {
	old := *pq
	n := len(old)
	st := old[n-1]
	*pq = old[0 : n-1]
	return st
}

func (pq *pqueue) Push(x interface{}) {
	st := x.(*state)
	*pq = append(*pq, st)
}

func (pq pqueue) Swap(i, j int) {
	pq[i], pq[j] = pq[j], pq[i]
}

type state struct {
	moves         int
	floors        []map[string]bool
	elevator      map[string]bool
	elevatorLevel int
	score         int
	mv            move
	visited       []map[string]bool
}

type move struct {
	from, to        int
	pickup, dropoff []string
}

func copyElevator(elevator map[string]bool) map[string]bool {
	cp := make(map[string]bool)
	for k, v := range elevator {
		cp[k] = v
	}
	return cp
}

func copyFloors(floors []map[string]bool) []map[string]bool {
	cp := make([]map[string]bool, len(floors))
	for i := 0; i < len(floors); i++ {
		cp[i] = make(map[string]bool)
		for k, v := range floors[i] {
			cp[i][k] = v
		}
	}
	return cp
}

func getKey(floors []map[string]bool, elevator map[string]bool, level int, mv move) string {
	key := "" //fmt.Sprintf("%d ", level)

	for floor, r := range floors {
		key += "|" + floorKey(r)
		if floor == level {
			key += "|e" + floorKey(elevator)
		}
	}
	return key
}

func floorKey(m map[string]bool) string {
	list := []string{}
	for k := range m {
		list = append(list, k)
	}
	sort.Strings(list)
	return listkey(list)
}

func listkey(list []string) string {
	return strings.Join(list, ",")
}

func isComplete(floors []map[string]bool, elevator map[string]bool) bool {
	complete := len(elevator) == 0
	for i := 0; i < len(floors)-1; i++ {
		complete = complete && len(floors[i]) == 0
	}

	return complete
}

func getScore(moves int, floors []map[string]bool, elevator map[string]bool, level int) int {
	mscore := 1 // 100 - moves
	fscore := len(floors[0])*mscore + 10*len(floors[1])*mscore + 100*len(floors[2])*mscore + 1000*len(floors[3])*mscore
	escore := int(math.Pow10(level)) * len(elevator) * mscore
	return fscore + escore
}

func main() {
	startTime := time.Now()

	floors := make([]map[string]bool, 4)
	floors[0] = map[string]bool{"PO-G": true, "TH-G": true, "TH-M": true, "PR-G": true, "RU-G": true, "RU-M": true, "CO-G": true, "CO-M": true}
	floors[1] = map[string]bool{"PO-M": true, "PR-M": true}
	floors[2] = map[string]bool{}
	floors[3] = map[string]bool{}

	runExample := len(os.Args) > 1 && os.Args[1] == "example"
	if runExample {
		fmt.Println("using example input")
		example := []map[string]bool{{"HH-M": true, "LL-M": true}, {"HH-G": true}, {"LL-G": true}}
		floors[0] = example[0]
		floors[1] = example[1]
		floors[2] = example[2]
	}

	p1 := part1(floors)
	fmt.Println("done part 1", time.Since(startTime), p1)
	p2 := part2(floors)

	fmt.Println("--2016 day 11 solution--")
	fmt.Println("(this one takes a few minutes)")
	fmt.Println("Part 1:", p1)
	fmt.Println("Part 2:", p2)

	fmt.Println("Time", time.Since(startTime))
}

func part1(floors []map[string]bool) output {
	b, i := simulate(floors)
	if b {
		return i
	}
	return 0
}

func part2(floors []map[string]bool) output {
	for _, s := range []string{"EL-G", "EL-M", "DI-G", "DI-M"} {
		floors[0][s] = true
	}
	b, i := simulate(floors)
	if b {
		return i
	}
	return 0
}

func simulate(floors []map[string]bool) (bool, int) {
	floorInit := copyFloors(floors)
	queue := pqueue{}
	mvs := getValidMoves(floorInit, map[string]bool{}, 0)

	for _, mv := range mvs {
		st := newState(floorInit, map[string]bool{}, mv, 0)
		queue = append(queue, st)
	}

	heap.Init(&queue)

	visited := make(map[string]int)
	moves := 1000
	solved := false
	start := time.Now()
	itr := 0

	for queue.Len() > 0 {
		cur := (heap.Pop(&queue)).(*state)

		if cur.moves >= moves {
			continue
		}

		if isComplete(cur.floors, cur.elevator) && cur.moves < moves {
			moves = cur.moves
			solved = true
			fmt.Println("found a solution", cur.moves, cur.floors)
			continue
		}

		mvs := getValidMoves(cur.floors, cur.elevator, cur.elevatorLevel)

		for _, mv := range mvs {
			// fmt.Println("mv", mv)
			// fmt.Println("cur---------")
			// fmt.Println("floors", cur.floors, "\nelevator", cur.elevator, "\nkey", getKey(cur.floors, cur.elevator, cur.currentLevel, cur.mv))
			// fmt.Println("pickup", cur.mv.pickup, "\ndropoff", cur.mv.dropoff, "\nlevel", cur.currentLevel)

			st := newState(cur.floors, cur.elevator, mv, cur.moves)

			key := getKey(st.floors, st.elevator, st.elevatorLevel, st.mv)
			if m, ok := visited[key]; ok && st.moves >= m {
				continue
			}
			visited[key] = st.moves
			// fmt.Println("--------\nfloors", st.floors, "\nelevator", st.elevator, "\nkey", key)
			// fmt.Println("pickup", st.mv.pickup, "\ndropoff", st.mv.dropoff, "\nlevel", st.currentLevel, "\n---------")

			enqueue := true
			// newkey := floorKey(st.floors[mv.currentLevel])
			// prevKey := floorKey(st.floors[mv.prevLevel])
			// //key := floorKey(cur.floors[mv.currentLevel])

			// var curvisit, prevvisit bool
			// _, curvisit = cur.visited[mv.currentLevel][newkey]
			// _, prevvisit = cur.visited[mv.prevLevel][prevKey]

			// if curvisit && prevvisit {
			// 	fmt.Println("already tried", newkey, "on floor", mv.currentLevel, prevKey, "on floor", mv.prevLevel)
			// 	enqueue = false
			// }

			if enqueue {
				queue.Push(st)
			}

			// fmt.Println("                                                  ", len(queue), st.moves, st.score)
		}
		if itr%100000 == 0 {
			fmt.Println(itr, time.Since(start), queue.Len(), cur.moves)
			start = time.Now()
		}
		itr++
	}

	return solved, moves
}

func newState(floors []map[string]bool, elevator map[string]bool, mv move, moves int) *state {
	cp := new(state)
	cp.floors = copyFloors(floors)
	cp.elevator = copyElevator(elevator)
	cp.moves = moves + 1
	cp.mv = mv
	// cp.visited = make([]map[string]bool, len(floors))
	// if prev != nil {
	// 	for i := 0; i < len(prev.visited); i++ {
	// 		cp.visited[i] = map[string]bool{}
	// 		for k, v := range prev.visited[i] {
	// 			cp.visited[i][k] = v
	// 		}
	// 	}
	// } else {
	// 	for i := 0; i < len(floors); i++ {
	// 		cp.visited[i] = map[string]bool{}
	// 	}
	// }

	if mv.dropoff != nil {
		// fmt.Println("dropoff", cp.elevator, mv.dropoff, cp.floors, mv.from, mv.to)
		transfer(cp.elevator, cp.floors[mv.to], mv.dropoff)
		cp.elevatorLevel = mv.to
		// fmt.Println("after", cp.elevator, mv.dropoff, cp.floors, mv.from, mv.to)
	}

	if mv.pickup != nil {
		// fmt.Println("pickup", cp.elevator, mv.pickup, cp.floors, mv.from, mv.to)
		transfer(cp.floors[mv.from], cp.elevator, mv.pickup)
		cp.elevatorLevel = mv.from
		// fmt.Println("after pickup", cp.elevator, mv.pickup, cp.floors, mv.from, mv.to)
	}
	// cp.visited[mv.currentLevel][floorKey(cp.floors[mv.currentLevel])] = true

	cp.score = getScore(cp.moves, cp.floors, cp.elevator, cp.elevatorLevel)
	return cp
}

func transfer(from map[string]bool, to map[string]bool, elements []string) {
	for _, element := range elements {
		if _, ok := from[element]; ok {
			if _, ok := to[element]; !ok {
				delete(from, element)
				to[element] = true
			}
		}
	}
}

func getValidMoves(floors []map[string]bool, elevator map[string]bool, currentLevel int) []move {
	mvs := getAllMoves(floors, elevator, currentLevel)
	validMoves := []move{}

	for _, mv := range mvs {
		valid := false
		if mv.dropoff != nil && safeToRemove(elevator, mv.dropoff) && safeToAdd(floors[mv.to], mv.dropoff) {
			valid = true
		}
		if mv.pickup != nil && safeToRemove(floors[mv.from], mv.pickup) && safeToAdd(elevator, mv.pickup) {
			valid = true
		}

		if valid {
			validMoves = append(validMoves, mv)
		}
	}

	return validMoves
}

func getAllMoves(floors []map[string]bool, elevator map[string]bool, currentLevel int) []move {
	mvs := []move{}

	for _, toFloor := range []int{currentLevel - 1, currentLevel + 1} {
		if toFloor == -1 || toFloor == len(floors) {
			continue
		}
		// if toFloor < currentLevel && len(floors[toFloor]) == 0 {
		// 	continue
		// }
		// don't drop off 2 below, only move up
		if len(elevator) == 2 && toFloor < currentLevel {
			continue
		}

		if len(elevator) > 0 {
			elements := []string{}
			for k := range elevator {
				elements = append(elements, k)
			}
			combos := [][]string{
				{elements[0]},
			}
			if len(elements) > 1 {
				combos = append(combos, [][]string{{}, {elements[1]}, {elements[0], elements[1]}}...)
			}
			for _, elements := range combos {
				mv := move{
					to:      toFloor,
					from:    currentLevel,
					dropoff: elements,
				}
				mvs = append(mvs, mv)
			}
		}

		// if toFloor < currentLevel && len(elevator) < 2 {
		// 	for elem := range floors[currentLevel] {
		// 		mv := move{
		// 			currentLevel: toFloor,
		// 			prevLevel:    currentLevel,
		// 			pickup:       []string{elem},
		// 		}
		// 		mvs = append(mvs, mv)
		// 	}
		// }

		lm := map[string]bool{}
		for left := range floors[currentLevel] {
			for right := range floors[currentLevel] {
				if left == right {
					continue
				}
				pk := []string{left, right}
				sort.Strings(pk)
				key := pk[0] + "|" + pk[1]
				if _, ok := lm[key]; ok {
					continue
				}
				lm[key] = true

				if _, ok := lm[left]; !ok && len(elevator) < 2 {
					lm[left] = true
					mvs = append(mvs, move{to: toFloor, pickup: []string{left}, from: currentLevel})
				}

				if _, ok := lm[right]; !ok && len(elevator) < 2 {
					lm[right] = true
					mvs = append(mvs, move{to: toFloor, pickup: []string{right}, from: currentLevel})
				}

				if len(elevator) == 0 {
					mvs = append(mvs, move{
						pickup: pk,
						to:     toFloor,
						from:   currentLevel,
					})
				}
			}
		}
	}
	return mvs
}

func safeToRemove(row map[string]bool, elements []string) bool {
	if len(elements) == 0 {
		return true
	}
	cp := make(map[string]bool, len(row))
	for element, _ := range row {
		cp[element] = true
	}
	for _, element := range elements {
		delete(cp, element)
	}
	return rowValid(cp)
}

func safeToAdd(row map[string]bool, elements []string) bool {
	if len(elements) == 0 {
		return true
	}
	cp := make(map[string]bool, len(row)+len(elements))
	for element, _ := range row {
		cp[element] = true
	}
	for _, element := range elements {
		cp[element] = true
	}
	return rowValid(cp)
}

func rowValid(row map[string]bool) bool {
	result := true
	for element, _ := range row {
		if isMicrochip(element) && !containsOwnGenerator(row, element) && containsOtherGenerator(row, element) {
			result = false
		}
	}

	return result
}

func isMicrochip(element string) bool {
	return strings.HasSuffix(element, "-M")
}

func containsOwnGenerator(row map[string]bool, element string) bool {
	gen := string(element[0:2]) + "-G"
	_, ok := row[gen]
	return ok
}

func containsOtherGenerator(row map[string]bool, element string) bool {
	result := false
	el := string(element[0:2])

	for r, _ := range row {
		if strings.HasSuffix(r, "-G") && !strings.HasPrefix(r, el) {
			result = true
		}
	}
	return result
}
